name: 'üè∑Ô∏è Issue Triage'

on:
  issues:
    types:
      - 'opened'
      - 'reopened'
  issue_comment:
    types:
      - 'created'
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to triage'
        required: true
        type: 'number'

concurrency:
  group: '${{ github.workflow }}-${{ github.event.issue.number || github.event.inputs.issue_number }}'
  cancel-in-progress: true

permissions:
  contents: 'read'
  issues: 'write'

jobs:
  add-needs-triage:
    if: github.event_name == 'issues' && github.event.action == 'opened'
    runs-on: 'ubuntu-latest'
    steps:
      - name: 'Add needs-triage label'
        uses: 'actions/github-script@v7'
        with:
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['needs-triage']
            });

  triage-issue:
    needs: [add-needs-triage]
    if: |
      always() && (
        github.event_name == 'workflow_dispatch' ||
        github.event_name == 'issues' ||
        (
          github.event_name == 'issue_comment' &&
          contains(github.event.comment.body, '/triage') &&
          (
            github.event.comment.author_association == 'OWNER' ||
            github.event.comment.author_association == 'MEMBER' ||
            github.event.comment.author_association == 'COLLABORATOR'
          )
        )
      )
    timeout-minutes: 10
    runs-on: 'ubuntu-latest'

    steps:
      - name: 'Check if already triaged'
        id: 'check_labels'
        if: github.event_name != 'workflow_dispatch'
        uses: 'actions/github-script@v7'
        with:
          script: |
            const labels = context.payload.issue?.labels?.map(l => l.name) || [];
            const triageLabels = ['bug', 'enhancement', 'documentation', 'question', 'invalid'];
            const areaLabels = labels.filter(l => l.startsWith('area/'));
            const hasTriageLabel = labels.some(l => triageLabels.includes(l)) || areaLabels.length > 0;
            const isRetriage = context.payload.comment?.body?.includes('/triage');
            
            if (hasTriageLabel && !isRetriage) {
              core.info(`Issue already triaged: ${labels.join(', ')}. Skipping.`);
              core.setOutput('skip', 'true');
            } else {
              core.setOutput('skip', 'false');
            }

      - name: 'Get issue data'
        id: 'get_issue'
        if: steps.check_labels.outputs.skip != 'true'
        uses: 'actions/github-script@v7'
        with:
          script: |
            const issueNumber = context.payload.inputs?.issue_number || context.issue?.number;
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(issueNumber),
            });
            core.setOutput('number', issue.number);
            core.setOutput('title', issue.title);
            core.setOutput('body', issue.body || '');

      - name: 'Get open issues for duplicate detection'
        id: 'get_issues'
        if: steps.check_labels.outputs.skip != 'true'
        uses: 'actions/github-script@v7'
        with:
          script: |
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 50,
              sort: 'updated',
              direction: 'desc'
            });
            
            const currentIssueNumber = parseInt('${{ steps.get_issue.outputs.number }}');
            const otherIssues = issues
              .filter(i => i.number !== currentIssueNumber && !i.pull_request)
              .map(i => `#${i.number}: ${i.title}`)
              .slice(0, 30)
              .join('\n');
            
            core.setOutput('list', otherIssues);

      - name: 'Triage with Jules API'
        id: 'jules_triage'
        if: steps.check_labels.outputs.skip != 'true'
        env:
          JULES_API_KEY: '${{ secrets.JULES_API_KEY }}'
        run: |
          RESPONSE=$(curl -s 'https://jules.googleapis.com/v1alpha/chat' \
            -X POST \
            -H "Content-Type: application/json" \
            -H "X-Goog-Api-Key: $JULES_API_KEY" \
            -d '{
              "model": "gemini-3-pro",
              "contents": [{
                "role": "user",
                "parts": [{"text": "'"$(cat <<'PROMPT'
          ## Role
          You are an expert triage assistant AND a master user of opencode-antigravity-auth.
          You know this plugin inside-out: the README, architecture, common issues, and troubleshooting steps.
          You are extremely helpful and want to solve users' problems quickly.
          
          This is an OpenCode plugin that enables OAuth authentication with Google's Antigravity API to access models like Claude Opus 4.5, Claude Sonnet 4.5, and Gemini 3 Pro.

          ## Current Issue to Triage
          Title: ${{ steps.get_issue.outputs.title }}
          Body: ${{ steps.get_issue.outputs.body }}

          ## Other Open Issues (check for duplicates)
          ${{ steps.get_issues.outputs.list }}

          ## Your Deep Knowledge

          ### How the plugin works
          - Intercepts fetch() calls to generativelanguage.googleapis.com
          - Transforms requests to Antigravity API format
          - Handles OAuth token exchange via Google credentials
          - Supports multi-account rotation on rate limits (429)
          - Strips Claude thinking blocks from outgoing requests (fixes signature errors)
          - Recovers interrupted tool sessions with synthetic tool_result blocks

          ### Common issues & solutions
          1. "403 Forbidden" ‚Üí OAuth token expired. Solution: Re-run `gemini auth login`
          2. "429 Too Many Requests" ‚Üí Rate limited. Solution: Add more accounts or wait
          3. "Model not found" ‚Üí Model name incorrect. Check supported models in README
          4. "Signature validation error" ‚Üí Fixed by thinking block stripping. Clear session if persists
          5. "tool_result_missing" ‚Üí Session interrupted. Plugin auto-recovers, retry if needed
          6. "antigravity.json not found" ‚Üí Copy config template from README
          7. Plugin not loading ‚Üí Check oh-my-opencode or DCP installation

          ### Configuration files
          - antigravity.json: Main config (accounts, endpoints)
          - accounts.json: Multi-account credentials

          ## Available Labels

          ### Type labels (pick exactly one)
          - bug: Something broken (errors, crashes, unexpected behavior)
          - enhancement: Feature request or improvement
          - documentation: Docs unclear/missing/outdated
          - question: User asking for help
          - invalid: Spam or off-topic

          ### Area labels (pick exactly one)
          - area/auth: OAuth, login, tokens, credentials, 403 errors
          - area/models: Model access, Claude/Gemini specific
          - area/config: Configuration files, setup
          - area/compat: Compatibility with OpenCode, DCP

          ## Task
          1. Select ONE type label
          2. Select ONE area label  
          3. Check if this is a DUPLICATE of another open issue (check the list above!)
          4. Provide a helpful response if you can solve the issue

          ## Output (ONLY valid JSON, no markdown)
          {
            "type_label": "bug",
            "area_label": "area/auth",
            "duplicate_of": null,
            "suggested_response": "This looks like an expired OAuth token. Try running `gemini auth login` to refresh your credentials."
          }

          If duplicate, set duplicate_of to the issue number:
          {
            "type_label": "bug",
            "area_label": "area/auth",
            "duplicate_of": 42,
            "suggested_response": "This appears to be a duplicate of #42. Please check that issue for updates."
          }
          PROMPT
          )"'"}]
              }]
            }')
          
          echo "Raw response: $RESPONSE"
          
          TEXT=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text // empty')
          if [ -z "$TEXT" ]; then
            echo "Failed to get response from Jules API"
            echo "result=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "result<<EOF" >> $GITHUB_OUTPUT
          echo "$TEXT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: 'Fallback to Gemini CLI if Jules fails'
        id: 'gemini_fallback'
        if: steps.check_labels.outputs.skip != 'true' && steps.jules_triage.outputs.result == ''
        uses: 'google-github-actions/run-gemini-cli@v0'
        env:
          ISSUE_TITLE: '${{ steps.get_issue.outputs.title }}'
          ISSUE_BODY: '${{ steps.get_issue.outputs.body }}'
          OTHER_ISSUES: '${{ steps.get_issues.outputs.list }}'
        with:
          gemini_api_key: '${{ secrets.GEMINI_API_KEY }}'
          prompt: |
            You are a triage assistant for opencode-antigravity-auth plugin.
            
            Issue Title: ${{ env.ISSUE_TITLE }}
            Issue Body: ${{ env.ISSUE_BODY }}
            
            Other open issues:
            ${{ env.OTHER_ISSUES }}
            
            Return JSON only:
            {"type_label": "bug|enhancement|documentation|question|invalid", "area_label": "area/auth|area/models|area/config|area/compat", "duplicate_of": null, "suggested_response": "..."}

      - name: 'Apply Labels and Respond'
        if: steps.check_labels.outputs.skip != 'true'
        uses: 'actions/github-script@v7'
        env:
          ISSUE_NUMBER: '${{ steps.get_issue.outputs.number }}'
          JULES_OUTPUT: '${{ steps.jules_triage.outputs.result }}'
          GEMINI_OUTPUT: '${{ steps.gemini_fallback.outputs.summary }}'
        with:
          script: |
            const rawOutput = process.env.JULES_OUTPUT || process.env.GEMINI_OUTPUT;
            if (!rawOutput) {
              core.warning('No triage output available');
              return;
            }
            
            core.info(`Triage output: ${rawOutput}`);
            
            let parsed;
            try {
              parsed = JSON.parse(rawOutput);
            } catch (e) {
              const match = rawOutput.match(/```(?:json)?\s*([\s\S]*?)\s*```/) || 
                           rawOutput.match(/\{[\s\S]*\}/);
              if (match) {
                parsed = JSON.parse(match[1] || match[0]);
              } else {
                core.setFailed(`Failed to parse output: ${rawOutput}`);
                return;
              }
            }
            
            const typeLabel = parsed.type_label;
            const areaLabel = parsed.area_label;
            const duplicateOf = parsed.duplicate_of;
            const suggestedResponse = parsed.suggested_response;
            
            const validTypeLabels = ['bug', 'enhancement', 'documentation', 'question', 'invalid'];
            const validAreaLabels = ['area/auth', 'area/models', 'area/config', 'area/compat'];
            
            const labelsToAdd = [];
            const labelsToRemove = ['needs-triage'];
            
            if (typeLabel && validTypeLabels.includes(typeLabel)) {
              labelsToAdd.push(typeLabel);
            }
            if (areaLabel && validAreaLabels.includes(areaLabel)) {
              labelsToAdd.push(areaLabel);
            }
            if (duplicateOf) {
              labelsToAdd.push('duplicate');
            }
            
            if (labelsToAdd.length === 0) {
              core.warning('No valid labels found, keeping needs-triage');
              return;
            }
            
            const issueNumber = parseInt(process.env.ISSUE_NUMBER);
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              labels: labelsToAdd
            });
            core.info(`Added labels: ${labelsToAdd.join(', ')}`);
            
            for (const label of labelsToRemove) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  name: label
                });
                core.info(`Removed label: ${label}`);
              } catch (e) {
                core.info(`Label ${label} not present, skipping removal`);
              }
            }
            
            if (suggestedResponse && suggestedResponse.trim()) {
              let body = `üëã Thanks for opening this issue!\n\n${suggestedResponse}`;
              
              if (duplicateOf) {
                body += `\n\nüîó This appears to be related to #${duplicateOf}. Please check that issue for updates.`;
              }
              
              body += `\n\n---\n*This is an automated response. A maintainer will review your issue soon.*`;
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: body
              });
              core.info('Posted response comment');
            }
            
            if (duplicateOf) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                state: 'closed',
                state_reason: 'not_planned'
              });
              core.info(`Closed as duplicate of #${duplicateOf}`);
            }

      - name: 'Comment on failure'
        if: failure()
        uses: 'actions/github-script@v7'
        env:
          ISSUE_NUMBER: '${{ steps.get_issue.outputs.number || github.event.issue.number }}'
          RUN_URL: '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
        with:
          script: |
            if (!process.env.ISSUE_NUMBER) return;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(process.env.ISSUE_NUMBER),
              body: `‚ö†Ô∏è Automated triage failed. [View logs](${process.env.RUN_URL})`
            });
